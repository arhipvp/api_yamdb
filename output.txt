============================= test session starts =============================
platform win32 -- Python 3.7.0, pytest-6.2.4, py-1.11.0, pluggy-0.13.1 -- c:\dev\api_yamdb\venv\scripts\python.exe
django: settings: api_yamdb.settings (from ini)
rootdir: C:\Dev\api_yamdb, configfile: pytest.ini, testpaths: tests/
plugins: django-4.4.0, pythonpath-0.7.3
collecting ... collected 77 items

tests/test_00_user_registration.py::Test00UserRegistration::test_00_nodata_signup FAILED [  1%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_invalid_data_signup FAILED [  2%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_singup_length_and_simbols_validation[data0-messege0] 

================================== FAILURES ===================================
________________ Test00UserRegistration.test_00_nodata_signup _________________

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000022F678B7DA0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv\lib\site-packages\django\core\handlers\base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000022F678B7DA0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv\lib\site-packages\django\core\handlers\base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB208>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F678C8EB8>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F678C8EB8>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9540, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E278>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E278>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9420, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x0000022F678B7FD0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67910508>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F679004E0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F679004E0>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F96F0, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E6A0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E6A0>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F95D0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x0000022F678B7F98>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67910E08>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900630>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900630>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F98A0, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790EA20>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790EA20>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9780, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x0000022F678B7BA8>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67918808>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900710>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900710>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9A50, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790EDA0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790EDA0>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9930, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x0000022F678AE3C8>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F6791F288>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900908>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900908>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9C00, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921160>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921160>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9AE0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.common.CommonMiddleware object at 0x0000022F678AE668>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F6791FCC8>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900E10>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900E10>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9DB0, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F679214E0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F679214E0>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9C90, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x0000022F677797F0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67922748>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900C88>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67900C88>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9F60, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921860>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921860>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678F9E40, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.security.SecurityMiddleware object at 0x0000022F678AEA58>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F679301C8>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E0F0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F6790E0F0>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F6792D150, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921BE0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67921BE0>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F6792D030, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x0000022F67513EB8>
client = <django.test.client.Client object at 0x0000022F678B7630>

    def test_00_nodata_signup(self, client):
>       response = client.post(self.url_signup)

tests\test_00_user_registration.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:751: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:408: in post
    secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:714: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:145: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:130: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:49: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:615: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:595: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python 3.7.0\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1006: in _gcd_import
    ???
<frozen importlib._bootstrap>:983: in _find_and_load
    ???
<frozen importlib._bootstrap>:967: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:677: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:728: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb\api_yamdb\urls.py:27: in <module>
    path('api/', include('api.urls'), name='api'),
venv\lib\site-packages\django\urls\conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
C:\Python 3.7.0\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1006: in _gcd_import
    ???
<frozen importlib._bootstrap>:983: in _find_and_load
    ???
<frozen importlib._bootstrap>:967: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:677: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:728: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError
---------------------------- Captured stdout setup ----------------------------
Operations to perform:
  Synchronize unmigrated apps: django_filters, messages, rest_framework, staticfiles
  Apply all migrations: admin, api, auth, contenttypes, reviews, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0001_initial... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying reviews.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying api.0001_initial... OK
  Applying api.0002_delete_genres... OK
  Applying reviews.0002_auto_20230119_2120... OK
  Applying reviews.0003_title_сategories... OK
  Applying reviews.0004_comment_review... OK
  Applying reviews.0005_alter_review_score... OK
  Applying reviews.0004_auto_20230121_2252... OK
  Applying reviews.0006_merge_0004_auto_20230121_2252_0005_alter_review_score... OK
  Applying reviews.0007_alter_title_year... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup ----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
_____________ Test00UserRegistration.test_00_invalid_data_signup ______________

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000022F67B8FB70>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv\lib\site-packages\django\core\handlers\base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000022F67B8FB70>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv\lib\site-packages\django\core\handlers\base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv\lib\site-packages\django\urls\resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB208>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv\lib\site-packages\django\urls\resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F198>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F198>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67AA0F60, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83CC0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83CC0>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F678C96F0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x0000022F67B8FCC0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67B92308>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F240>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F240>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD1E0, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83D68>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83D68>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD150, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x0000022F67B8FE80>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67AF49C8>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F3C8>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B8F3C8>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD300, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83198>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83198>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD270, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x0000022F67B8FDD8>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67AF4488>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB5128>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB5128>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD420, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B834A8>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B834A8>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD390, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x0000022F67B8FD30>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67B6B848>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB57F0>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB57F0>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD540, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84E48>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84E48>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD4B0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.common.CommonMiddleware object at 0x0000022F67B8FCF8>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67AA4C08>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB5390>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67BB5390>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD660, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84128>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84128>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD5D0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x0000022F67B8FC88>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67AA4988>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B96C88>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B96C88>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD810, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84470>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84470>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD6F0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.middleware.security.SecurityMiddleware object at 0x0000022F67B8FE48>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv\lib\site-packages\django\utils\deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv\lib\site-packages\django\core\handlers\exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n'))

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv\lib\site-packages\django\core\handlers\exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'SyntaxError'>, SyntaxError('invalid syntax', ('C:\\Dev\\api_yamdb\\api_yamdb\\api\\views.py', 63, 32, '        if self.request.user. == IsAdminUser:\n')), <traceback object at 0x0000022F67AECC08>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv\lib\site-packages\django\core\handlers\exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv\lib\site-packages\django\urls\resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.utils.functional.cached_property object at 0x0000022F661AB1D0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv\lib\site-packages\django\utils\functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv\lib\site-packages\django\urls\resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83940>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B83940>
module = <module 'api_yamdb.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api_yamdb\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD9C0, file "C:\Dev\api_yamdb\api_yamdb\api_yamdb\urls.py", line 15>, {'Templat... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    from django.contrib import admin
    from django.urls import include, path
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls'), name='api'),
    ]

api_yamdb\api_yamdb\urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv\lib\site-packages\django\urls\conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

C:\Python 3.7.0\lib\importlib\__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1006: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'api.urls', import_ = <function _gcd_import at 0x0000022F6445BE18>

>   ???

<frozen importlib._bootstrap>:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84710>, origin='C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py')

>   ???

<frozen importlib._bootstrap>:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_frozen_importlib_external.SourceFileLoader object at 0x0000022F67B84710>
module = <module 'api.urls' from 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py'>

>   ???

<frozen importlib._bootstrap_external>:728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function exec>
args = (<code object <module> at 0x0000022F67BCD8A0, file "C:\Dev\api_yamdb\api_yamdb\api\urls.py", line 1>, {'__builtins__':...i\\__pycache__\\urls.cpython-37.pyc', '__doc__': None, '__file__': 'C:\\Dev\\api_yamdb\\api_yamdb\\api\\urls.py', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x0000022F6763E518>
client = <django.test.client.Client object at 0x0000022F67B8FF60>
django_user_model = <class 'reviews.models.User'>

    def test_00_invalid_data_signup(self, client, django_user_model):
        invalid_data = {
            'email': 'invalid_email',
            'username': ' '
        }
        users_count = django_user_model.objects.count()
    
>       response = client.post(self.url_signup, data=invalid_data)

tests\test_00_user_registration.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:751: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:408: in post
    secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:714: in request
    response = self.handler(environ)
venv\lib\site-packages\django\test\client.py:145: in __call__
    response = self.get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:130: in get_response
    response = self._middleware_chain(request)
venv\lib\site-packages\django\core\handlers\exception.py:49: in inner
    response = response_for_exception(request, exc)
venv\lib\site-packages\django\core\handlers\exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv\lib\site-packages\django\core\handlers\exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
venv\lib\site-packages\django\urls\resolvers.py:615: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv\lib\site-packages\django\utils\functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv\lib\site-packages\django\urls\resolvers.py:595: in urlconf_module
    return import_module(self.urlconf_name)
C:\Python 3.7.0\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1006: in _gcd_import
    ???
<frozen importlib._bootstrap>:983: in _find_and_load
    ???
<frozen importlib._bootstrap>:967: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:677: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:728: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb\api_yamdb\urls.py:27: in <module>
    path('api/', include('api.urls'), name='api'),
venv\lib\site-packages\django\urls\conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
C:\Python 3.7.0\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1006: in _gcd_import
    ???
<frozen importlib._bootstrap>:983: in _find_and_load
    ???
<frozen importlib._bootstrap>:967: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:677: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:728: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   from api.views import AuthSignup, AuthToken, СategoriesViewSet, GenresViewSet, UsersViewSet, TitleViewSet, ReviewsViewSet, CommentsViewSet
E     File "C:\Dev\api_yamdb\api_yamdb\api\views.py", line 63
E       if self.request.user. == IsAdminUser:
E                              ^
E   SyntaxError: invalid syntax

api_yamdb\api\urls.py:1: SyntaxError
============================== warnings summary ===============================
venv\lib\site-packages\pkg_resources\_vendor\pyparsing.py:943
  c:\dev\api_yamdb\venv\lib\site-packages\pkg_resources\_vendor\pyparsing.py:943: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working
    collections.MutableMapping.register(ParseResults)

venv\lib\site-packages\pkg_resources\_vendor\pyparsing.py:3226
  c:\dev\api_yamdb\venv\lib\site-packages\pkg_resources\_vendor\pyparsing.py:3226: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working
    elif isinstance( exprs, collections.Iterable ):

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ===========================
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_nodata_signup
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_invalid_data_signup
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C:\Python 3.7.0\lib\ast.py:179: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
======================== 2 failed, 2 warnings in 2.01s ========================
